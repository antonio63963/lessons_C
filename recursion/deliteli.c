void printFactor(unsigned int last, unsigned int n) {
    if (n > 0) {
        printf("%u", last);
        if (n > 1) {
            printf("^%u", n);
        }
        printf(" "); // Печать пробела после каждого сомножителя
    }
}

/**
 * @brief Рекурсивно находит и печатает простые сомножители числа a
 * в порядке убывания.
 *
 * @param a Оставшееся число для разложения.
 * @param last Текущий предполагаемый сомножитель.
 * @param n Степень текущего сомножителя в числе.
 */
void simpleFactors(unsigned int a, unsigned int last, unsigned int n) {
    // Рекомендуемая отладочная печать (можно удалить для финального решения):
    // printf("DEBUG: a=%u, last=%u, n=%u\n", a, last, n);

    // --- Шаг 1: Обработка текущего простого сомножителя (last) ---
    // Этот цикл находит степень сомножителя 'last' в числе 'a'.
    while (a != 0 && a % last == 0) {
        a /= last; // Делим 'a' на 'last'
        n++;       // Увеличиваем степень
    }
    
    // --- Шаг 2: Условие остановки рекурсии ---
    // Если после деления 'a' стало 1, значит, мы полностью разложили
    // исходное число.
    if (a == 1) {
        // Мы достигли конца. Печатаем последний найденный сомножитель
        // и начинаем возврат из рекурсии.
        printFactor(last, n);
        return;
    }

    // --- Шаг 3: Переход к следующему сомножителю ---
    unsigned int next_last;
    if (last == 2) {
        // Если текущий сомножитель 2, следующий - 3
        next_last = 3;
    } else {
        // Для всех остальных нечетных сомножителей, следующий - на 2 больше
        next_last = last + 2;
    }

    // --- Шаг 4: Вызов рекурсии ---
    // Рекурсивный вызов для оставшегося числа 'a' и следующего предполагаемого сомножителя.
    simpleFactors(a, next_last, 0);

    // --- Шаг 5: Отложенная печать ---
    // Код здесь выполняется при возврате из рекурсии (после того,
    // как были напечатаны сомножители, найденные глубже).
    // Это обеспечивает печать в порядке убывания сомножителей.
    printFactor(last, n);
}